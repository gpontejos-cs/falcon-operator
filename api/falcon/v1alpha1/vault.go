//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// +kubebuilder:skip

package v1alpha1

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/crowdstrike/falcon-operator/pkg/vault"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)


// VaultClientManager provides an interface for managing Vault clients
type VaultClientManager interface {
	GetVaultClient(ctx context.Context, vaultConfig *VaultConfig, namespace string) (*vault.MultiClusterClient, error)
}

// DefaultVaultClientManager implements VaultClientManager with client caching
type DefaultVaultClientManager struct {
	K8sClient    client.Client
	VaultClients map[string]*vault.MultiClusterClient
}

// NewVaultClientManager creates a new DefaultVaultClientManager
func NewVaultClientManager(k8sClient client.Client) *DefaultVaultClientManager {
	return &DefaultVaultClientManager{
		K8sClient:    k8sClient,
		VaultClients: make(map[string]*vault.MultiClusterClient),
	}
}

// DetermineClusterID determines the cluster ID based on the vault configuration
func (v *VaultConfig) DetermineClusterID(ctx context.Context, k8sClient client.Client) (string, error) {
	multiClusterConfig := v.MultiCluster

	// Use explicit cluster ID if provided
	if multiClusterConfig.ClusterID != "" {
		return multiClusterConfig.ClusterID, nil
	}

	// Auto-detect if enabled
	if multiClusterConfig.AutoDetectCluster {
		return autoDetectClusterID(ctx, k8sClient)
	}

	return "", fmt.Errorf("cluster ID not specified and auto-detection disabled")
}

// autoDetectClusterID attempts to automatically detect the cluster ID
func autoDetectClusterID(ctx context.Context, k8sClient client.Client) (string, error) {
	// Try environment variable first
	if clusterID := os.Getenv("CLUSTER_ID"); clusterID != "" {
		return clusterID, nil
	}

	// Try node labels
	nodeList := &corev1.NodeList{}
	if err := k8sClient.List(ctx, nodeList, client.Limit(1)); err == nil && len(nodeList.Items) > 0 {
		node := nodeList.Items[0]

		// Check common cluster ID labels
		clusterIDLabels := []string{
			"cluster.company.com/id",
			"cluster.x-k8s.io/cluster-name",
			"node.kubernetes.io/cluster",
			"topology.kubernetes.io/region",
		}

		for _, label := range clusterIDLabels {
			if clusterID, ok := node.Labels[label]; ok && clusterID != "" {
				return clusterID, nil
			}
		}

		// Try to extract from node name (e.g., gke-cluster-name-pool-xyz)
		if strings.Contains(node.Name, "-") {
			parts := strings.Split(node.Name, "-")
			if len(parts) >= 2 {
				return strings.Join(parts[:2], "-"), nil
			}
		}
	}

	return "", fmt.Errorf("could not auto-detect cluster ID")
}

// GetVaultClient gets or creates a vault client for the given configuration
func (m *DefaultVaultClientManager) GetVaultClient(ctx context.Context, vaultConfig *VaultConfig, namespace string) (*vault.MultiClusterClient, error) {
	// Determine cluster ID
	clusterID, err := vaultConfig.DetermineClusterID(ctx, m.K8sClient)
	if err != nil {
		return nil, fmt.Errorf("failed to determine cluster ID: %w", err)
	}

	// Return cached client if available and authenticated
	if client, exists := m.VaultClients[clusterID]; exists && client.IsAuthenticated() {
		return client, nil
	}

	// Load TLS configuration
	tlsConfig, err := loadTLSConfig(ctx, m.K8sClient, vaultConfig.TLS, namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to load TLS config: %w", err)
	}

	// Create new client
	config := vault.ClientConfig{
		VaultAddress:            vaultConfig.Address,
		ClusterID:               clusterID,
		Role:                    vaultConfig.MultiCluster.Role,
		AuthPath:                vaultConfig.MultiCluster.AuthPath,
		ServiceAccount:          vaultConfig.MultiCluster.ServiceAccount,
		ServiceAccountNamespace: vaultConfig.MultiCluster.ServiceAccountNamespace,
		TLSConfig:               tlsConfig,
	}

	client, err := vault.NewMultiClusterClient(config)
	if err != nil {
		return nil, err
	}

	// Cache the client
	m.VaultClients[clusterID] = client

	return client, nil
}

// loadTLSConfig loads TLS configuration from Kubernetes secrets
func loadTLSConfig(ctx context.Context, k8sClient client.Client, tlsConfig *VaultTLSConfig, namespace string) (*vault.TLSConfig, error) {
	if tlsConfig == nil {
		return &vault.TLSConfig{}, nil
	}

	config := &vault.TLSConfig{
		InsecureSkipVerify: tlsConfig.InsecureSkipVerify,
	}

	// Load CA certificate
	if tlsConfig.CASecret != "" {
		secret := &corev1.Secret{}
		if err := k8sClient.Get(ctx, types.NamespacedName{Name: tlsConfig.CASecret, Namespace: namespace}, secret); err != nil {
			return nil, fmt.Errorf("failed to get CA secret %s: %w", tlsConfig.CASecret, err)
		}

		if caData, ok := secret.Data["ca.crt"]; ok {
			config.CAData = caData
		} else {
			return nil, fmt.Errorf("ca.crt not found in secret %s", tlsConfig.CASecret)
		}
	}

	// Load client certificate
	if tlsConfig.ClientCertSecret != "" {
		secret := &corev1.Secret{}
		if err := k8sClient.Get(ctx, types.NamespacedName{Name: tlsConfig.ClientCertSecret, Namespace: namespace}, secret); err != nil {
			return nil, fmt.Errorf("failed to get client cert secret %s: %w", tlsConfig.ClientCertSecret, err)
		}

		if certData, ok := secret.Data["tls.crt"]; ok {
			config.ClientCertData = certData
		}
		if keyData, ok := secret.Data["tls.key"]; ok {
			config.ClientKeyData = keyData
		}
	}

	return config, nil
}

// FetchSecretsFromVault fetches secrets from Vault using the provided client
func FetchSecretsFromVault(ctx context.Context, client *vault.MultiClusterClient, secrets []VaultSecret) (map[string]string, error) {
	secretData := make(map[string]string)

	for _, secret := range secrets {
		value, err := client.GetSecret(ctx, secret.Path, secret.Key, secret.ClusterSpecific)
		if err != nil {
			return nil, fmt.Errorf("failed to get secret %s/%s: %w", secret.Path, secret.Key, err)
		}
		secretData[secret.EnvVar] = value
	}

	return secretData, nil
}
